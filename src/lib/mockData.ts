import { AssignmentData, Question, StudentSubmission, QuestionInsights } from "@/types";

export const questions: Question[] = [
  { id: "q1", title: "Implementing Binary Search", maxScore: 25 },
  { id: "q2", title: "Dynamic Programming - Fibonacci", maxScore: 25 },
  { id: "q3", title: "Graph Traversal (BFS)", maxScore: 25 },
  { id: "q4", title: "Time Complexity Analysis", maxScore: 25 },
];

export const mockSubmissions: StudentSubmission[] = [
  {
    id: "sub1",
    studentName: "Alice Johnson",
    studentId: "STU001",
    email: "alice@university.edu",
    submittedAt: new Date("2024-11-01T10:30:00"),
    totalScore: 92,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 24, feedback: "Excellent implementation with edge cases handled properly." },
      { questionId: "q2", score: 23, feedback: "Good use of memoization, minor optimization missed." },
      { questionId: "q3", score: 25, feedback: "Perfect BFS implementation." },
      { questionId: "q4", score: 20, feedback: "Correct analysis but could be more detailed." },
    ],
  },
  {
    id: "sub2",
    studentName: "Bob Smith",
    studentId: "STU002",
    email: "bob@university.edu",
    submittedAt: new Date("2024-11-01T11:15:00"),
    totalScore: 78,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 20, feedback: "Good logic but missed edge case for empty arrays." },
      { questionId: "q2", score: 18, feedback: "Recursive solution works but lacks optimization." },
      { questionId: "q3", score: 22, feedback: "BFS implementation correct but queue initialization could be improved." },
      { questionId: "q4", score: 18, feedback: "Basic understanding shown, needs more depth in analysis." },
    ],
  },
  {
    id: "sub3",
    studentName: "Carol Williams",
    studentId: "STU003",
    email: "carol@university.edu",
    submittedAt: new Date("2024-11-01T09:45:00"),
    totalScore: 85,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 22, feedback: "Solid implementation with good test cases." },
      { questionId: "q2", score: 21, feedback: "Well-optimized solution using tabulation." },
      { questionId: "q3", score: 23, feedback: "Good BFS approach with clear code structure." },
      { questionId: "q4", score: 19, feedback: "Good analysis but missed some edge cases." },
    ],
  },
  {
    id: "sub4",
    studentName: "David Brown",
    studentId: "STU004",
    email: "david@university.edu",
    submittedAt: new Date("2024-11-01T14:20:00"),
    totalScore: 65,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 15, feedback: "Logic errors in boundary conditions." },
      { questionId: "q2", score: 18, feedback: "Correct approach but inefficient implementation." },
      { questionId: "q3", score: 16, feedback: "BFS concept understood but implementation has bugs." },
      { questionId: "q4", score: 16, feedback: "Incomplete complexity analysis." },
    ],
  },
  {
    id: "sub5",
    studentName: "Emma Davis",
    studentId: "STU005",
    email: "emma@university.edu",
    submittedAt: new Date("2024-11-01T13:00:00"),
    totalScore: 88,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 23, feedback: "Clean implementation with good error handling." },
      { questionId: "q2", score: 22, feedback: "Efficient DP solution with clear comments." },
      { questionId: "q3", score: 24, feedback: "Excellent BFS with proper visited tracking." },
      { questionId: "q4", score: 19, feedback: "Thorough analysis with minor notation issues." },
    ],
  },
  {
    id: "sub6",
    studentName: "Frank Miller",
    studentId: "STU006",
    email: "frank@university.edu",
    submittedAt: new Date("2024-11-01T12:30:00"),
    totalScore: 72,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 18, feedback: "Functional but lacks optimization." },
      { questionId: "q2", score: 19, feedback: "Correct recursive solution, needs memoization." },
      { questionId: "q3", score: 20, feedback: "BFS works but code could be cleaner." },
      { questionId: "q4", score: 15, feedback: "Basic understanding but analysis is superficial." },
    ],
  },
  {
    id: "sub7",
    studentName: "Grace Lee",
    studentId: "STU007",
    email: "grace@university.edu",
    submittedAt: new Date("2024-11-01T10:00:00"),
    totalScore: 95,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 25, feedback: "Perfect implementation with excellent edge case handling." },
      { questionId: "q2", score: 24, feedback: "Outstanding DP solution with optimal space complexity." },
      { questionId: "q3", score: 24, feedback: "Excellent BFS implementation." },
      { questionId: "q4", score: 22, feedback: "Comprehensive and detailed analysis." },
    ],
  },
  {
    id: "sub8",
    studentName: "Henry Wilson",
    studentId: "STU008",
    email: "henry@university.edu",
    submittedAt: new Date("2024-11-01T15:45:00"),
    totalScore: 58,
    maxScore: 100,
    questionScores: [
      { questionId: "q1", score: 12, feedback: "Significant logic errors in implementation." },
      { questionId: "q2", score: 15, feedback: "Approach is correct but has multiple bugs." },
      { questionId: "q3", score: 14, feedback: "BFS concept not fully understood, queue management issues." },
      { questionId: "q4", score: 17, feedback: "Partial understanding of complexity analysis." },
    ],
  },
];

export const questionInsights: QuestionInsights[] = [
  {
    questionId: "q1",
    questionTitle: "Implementing Binary Search",
    averageScore: 19.9,
    maxScore: 25,
    insights: "Most students demonstrated a solid understanding of binary search principles. However, edge case handling remains a common weakness, particularly with empty arrays and single-element arrays. Students who scored highest paid attention to boundary conditions and implemented proper test cases.",
    commonMistakes: [
      "Not handling empty array edge case",
      "Incorrect boundary conditions (off-by-one errors)",
      "Missing validation for sorted array assumption",
      "Integer overflow in midpoint calculation",
    ],
  },
  {
    questionId: "q2",
    questionTitle: "Dynamic Programming - Fibonacci",
    averageScore: 20.0,
    maxScore: 25,
    insights: "Students showed varied approaches to solving the Fibonacci problem. Top performers utilized memoization or tabulation effectively, achieving O(n) time complexity. Lower-scoring submissions often used naive recursion without optimization, resulting in exponential time complexity. Understanding of DP principles needs reinforcement for about 40% of the class.",
    commonMistakes: [
      "No memoization in recursive solution",
      "Inefficient space complexity",
      "Missing base case handling",
      "Not considering integer overflow for large n",
    ],
  },
  {
    questionId: "q3",
    questionTitle: "Graph Traversal (BFS)",
    averageScore: 21.0,
    maxScore: 25,
    insights: "BFS implementation was generally well-understood, with most students correctly using a queue data structure. Common issues included improper visited node tracking and incorrect initialization of the queue. Students who excelled demonstrated clear understanding of graph representation and traversal order.",
    commonMistakes: [
      "Not marking nodes as visited before adding to queue",
      "Incorrect queue implementation or usage",
      "Missing handling for disconnected graphs",
      "Improper neighbor iteration logic",
    ],
  },
  {
    questionId: "q4",
    questionTitle: "Time Complexity Analysis",
    averageScore: 18.3,
    maxScore: 25,
    insights: "Time complexity analysis proved challenging for many students. While basic understanding of Big-O notation was evident, detailed analysis of nested loops and recursive functions needs improvement. Only 50% of students correctly analyzed all given code snippets. This suggests the need for more practice with complexity analysis.",
    commonMistakes: [
      "Confusing O(n) with O(log n) for divide-and-conquer",
      "Incorrect analysis of nested loops",
      "Not accounting for hidden complexity in library functions",
      "Incomplete justification for complexity claims",
    ],
  },
];

export const mockAssignmentData: AssignmentData = {
  title: "Data Structures & Algorithms - Assignment 3",
  questions,
  submissions: mockSubmissions,
  overallInsights: "Overall, the class performed well with an average score of 79.1%. Strong performance was observed in graph traversal and dynamic programming concepts. However, there's room for improvement in time complexity analysis and edge case handling. Students who scored in the top quartile consistently demonstrated thorough testing and consideration of boundary conditions. The bottom quartile struggled primarily with optimization techniques and formal complexity analysis. Consider additional office hours focused on Big-O notation and common algorithmic patterns.",
  questionInsights,
};
